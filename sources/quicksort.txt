Семейство быстрых сортировок
=========================================

Быстрая сортировка - это алгоритм сортировки, время работы которого для входного массива из n чисел в наихудшем случае равно tetta(n^2). Несмотря на такую медленную работу, в среднем время выполнения алгоритма намного лучше O(n^2).

Описание быстрой сортировки
---------------------------

Алгоритм быстрой сортировки основан на парадигме "разделяй и властвуй". Процесс сортировки подмассива A[p...r] состоит из трех этапов:

**Разделение**
Массив A[p...r] разбивается на два подмассива (путем переупорядочения его элементов) A[p...q-1] и A[q+1...r]. Каждый элемент в подмассиве A[p...q-1] не превышает значения элемента A[q]; элементы в подмассиве A[q+1...r] больше элемента A[q]. Индекс q вычисляется в ходе выполнения процедуры.

**Покорение**
Подмассивы A[p...q-1] и A[q+1...r] сортируются путем вызова процедуры быстрой сортировки.

**Комбинирование**
Поскольку подмассивы сортируются на месте, для их объединения не нужны никакие действия; весь массив A[p...r] оказывается отсортированным.


Реализация алгоритма быстрой сортировки на языке Java
---------------------------------

Метод quicksort()::

	public void qsort(int p, int r){
		if (p < r){
			int q = partition(p, r);
			sort(p, q - 1);
			sort(q + 1, r);
		}
	}

Метод разбиения массива partition(p,r)::
	
	private int partition(int p, int r){
		int x = arr[r];
		int i = p - 1;
		
		for (j = p; j < r - 1; j++){
			if (arr[j] <= x){
				++i;
				int temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
			}
		}

		int temp = arr[i+1];
		arr[i+1] = arr[r];
		arr[r] = temp;
		
		return i + 1;
	}

Анализ времени выполнения алгоритма быстрой сортировки
-------------------------

Время выполнения алгоритма быстрой сортировки зависит от того, какой элемент выбран в качестве опорного (pivot) т.е. от **степени сбалансированности**. Если разбиение сбалансированное, то алгоритм работает так же быстро, как и сортировка слиянием, в противном случае время выполнения алгоритма такое же как и у алгоритма сортировки вставкой.

Наихудшее разбиение
^^^^^^^^^^^^^^^^^^^

Наихудшее разбиение имеет место быть, когда процедура разбиения возвращает два подмассива: один длиной 0 элементов, второй n-1.

Рекуррентное соотношение, описывающее время работы процедуры сортировки массива::

	T(n) = Thetta(n) + T(0) + T(n-1) = Thetta(n) + T(n-1)

Время, затрачиваемое на разделение массива на подмассивы равно Thetta(n), т.к. выполняется сравнение каждого элемента массива с значением опорного элемента n раз. Время выполнения процедуры quicksort(p,0) равно 0, т.к. процедура сразу же завершает свое выполнение. Методом подстановки T(n - 1) = &Theta;(n-1) + T(n - 2) мы можем получить следующее выражение::

	T(n) = Thetta(n) + Thetta(n - 1) + Thetta(n - 2) + ... = Thetta(n^2)

Таким образом, если на каждом уровне рекурсии разбиение максимально несбалансированное, то время выполнения алгоритма быстрой сортировки равно Thetta(n^2).

Примечание от автора:
Думаю, что наихудшее разбиение возникает тогда, когда массив отсортирован в порядке убывания, а процедура сортировки выполняет сортировку такого массива по возрастанию. В этом случае опорный элемент становится минимальным, и следовательно процедура разбиения будет возвращать q = 1, что породит два подмассива, один длиной 0 элементов, другой n - 1 элементов.

Наилучшее разбиение
^^^^^^^^^^^^^^^^^^^

В самом благоприятном случае процедура разбиения массива делит задачу на две подзадачи, размер каждой из которых не превышает n/2. В этом случае алгоритм быстрой сортировки работает намного быстрее, время работы описывается следующим рекурректным уравнением::

	T(n) <= 2T(n/2) + Thetta(n)
	T(n) = O(n lgn)

Сбалансированное разбиение
^^^^^^^^^^^^^^^^^^^^^^^^^^

Разбиение даже в соотношении девяносто девять к одному приводит к тому, что время выполнения алгоритма будет равно О(nlgn). Несмотря на то, что такое разбиение выглядит несбалансированным, в асимптотическом пределе алгоритм ведет себя так же, как и при делении задачи на две одинаковые подзадачи.


Рандомизированная быстрая сортировка
------------------------------------

Исследуя поведение алгоритма быстрой сортировки в среднем случае, мы сделали предположение, что все элементы встречаются с равной вероятностью. Однако на практике это далеко не всегда так. Путем добавления этапа рандомизации можно получить среднюю производительность во всех случаях. Многие считают такую версию быстрой сортировки оптимальной для обработки больших массивов.

Случайная выборка
^^^^^^^^^^^^^^^^^

Вместо того, чтобы в качестве опорного элемента подмассива выбирать всегда элемент arr[r], можно выбрать случайный элемент среди элементов с индексами от p до r. Благодаря случайному выбору опорного элемента, можно ожидать что разбиение в среднем случае окажется довольно сбалансированным.

	private int randomPartition(int p, int r){
		int indexes = p - r;
		
		if (indexes > 0){
			int rnd = generator.nextInt(indexes);
		
			int temp = arr[r];
			arr[r] = arr[rnd];
			arr[rnd] = temp;
		}
		
		return partition(p, r);
	}

	private int randomPartition(int p, int r){
		int indexes = p - r;
		
		if (indexes > 0){
			int rnd = generator.nextInt(indexes);
			int temp = arr[r];
			arr[r] = arr[rnd];
			arr[rnd] = temp;
		}
		
		return partition(p, r);
	}
	
