Семейство быстрых сортировок
=========================================

Быстрая сортировка - это алгоритм сортировки, время работы которого для входного массива из n чисел в наихудшем случае равно tetta(n^2). Несмотря на такую медленную работу, в среднем время выполнения алгоритма намного лучше O(n^2).

Описание быстрой сортировки
---------------------------

Алгоритм быстрой сортировки основан на парадигме "разделяй и властвуй". Процесс сортировки подмассива A[p...r] состоит из трех этапов:

**Разделение**
Массив A[p...r] разбивается на два подмассива (путем переупорядочения его элементов) A[p...q-1] и A[q+1...r]. Каждый элемент в подмассиве A[p...q-1] не превышает значения элемента A[q]; элементы в подмассиве A[q+1...r] больше элемента A[q]. Индекс q вычисляется в ходе выполнения процедуры.

**Покорение**
Подмассивы A[p...q-1] и A[q+1...r] сортируются путем вызова процедуры быстрой сортировки.

**Комбинирование**
Поскольку подмассивы сортируются на месте, для их объединения не нужны никакие действия; весь массив A[p...r] оказывается отсортированным.


Реализация алгоритма быстрой сортировки на языке Java
---------------------------------

Метод quicksort()::

	public void qsort(int p, int r){
		if (p < r){
			int q = partition(p, r);
			sort(p, q - 1);
			sort(q + 1, r);
		}
	}

Метод разбиения массива partition(p,r)::
	
	private int partition(int p, int r){
		int x = arr[r];
		int i = p - 1;
		
		for (j = p; j < r - 1; j++){
			if (arr[j] <= x){
				++i;
				int temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
			}
		}

		int temp = arr[i+1];
		arr[i+1] = arr[r];
		arr[r] = temp;
		
		return i + 1;
	}

Анализ времени выполнения алгоритма быстрой сортировки
-------------------------

Время выполнения алгоритма быстрой сортировки зависит от того, какой элемент выбран в качестве опорного (pivot) т.е. от **степени сбалансированности**. Если разбиение сбалансированное, то алгоритм работает так же быстро, как и сортировка слиянием, в противном случае время выполнения алгоритма такое же как и у алгоритма сортировки вставкой.

Наихудшее разбиение
^^^^^^^^^^^^^^^^^^^

Наихудшее разбиение имеет место быть, когда процедура разбиения возвращает два подмассива: один длиной 0 элементов, второй n-1.

Рекуррентное соотношение, описывающее время работы процедуры сортировки массива::

	T(n) = Thetta(n) + T(0) + T(n-1) = Thetta(n) + T(n-1)

Время, затрачиваемое на разделение массива на подмассивы равно Thetta(n), т.к. выполняется сравнение каждого элемента массива с значением опорного элемента n раз. Время выполнения процедуры quicksort(p,0) равно 0, т.к. процедура сразу же завершает свое выполнение. Методом подстановки T(n - 1) = &Theta;(n-1) + T(n - 2) мы можем получить следующее выражение::

	T(n) = Thetta(n) + Thetta(n - 1) + Thetta(n - 2) + ... = Thetta(n^2)

Таким образом, если на каждом уровне рекурсии разбиение максимально несбалансированное, то время выполнения алгоритма быстрой сортировки равно Thetta(n^2).

Примечание от автора:
Думаю, что наихудшее разбиение возникает тогда, когда массив отсортирован в порядке убывания, а процедура сортировки выполняет сортировку такого массива по возрастанию. В этом случае опорный элемент становится минимальным, и следовательно процедура разбиения будет возвращать q = 1, что породит два подмассива, один длиной 0 элементов, другой n - 1 элементов.

Наилучшее разбиение
^^^^^^^^^^^^^^^^^^^

В самом благоприятном случае процедура разбиения массива делит задачу на две подзадачи, размер каждой из которых не превышает n/2. В этом случае алгоритм быстрой сортировки работает намного быстрее, время работы описывается следующим рекурректным уравнением::

	T(n) <= 2T(n/2) + Thetta(n)
	T(n) = O(n lgn)

Сбалансированное разбиение
^^^^^^^^^^^^^^^^^^^^^^^^^^

Разбиение даже в соотношении девяносто девять к одному приводит к тому, что время выполнения алгоритма будет равно О(nlgn). Несмотря на то, что такое разбиение выглядит несбалансированным, в асимптотическом пределе алгоритм ведет себя так же, как и при делении задачи на две одинаковые подзадачи.
	
